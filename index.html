
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>NatureRan</title>
        <meta name="author" content="Nature">
        <meta name="description" content="NatureRan ">
        <meta name="keywords" content="java">
        <link rel="icon" href="https://raw.githubusercontent.com/NatureRan/Images/main/benghuai11-headImg.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">NatureRan</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NatureRan</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(https://github.com/NatureRan/Images/raw/main/benghuai11.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>NatureRan</h1>
                <h3>Welcome To Ran&#39;s Blog</h3>
                <h5>NatureRan </h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/09/02/SpringBoot事务提交后执行后续操作/">
        <h2 class="post-title">SpringBoot事务提交后执行后续操作</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>业务需求上经常会有一些边缘操作，比如主流程操作A：用户报名课程操作入库，边缘操作B：发送邮件或短信通知。</p>
<h2 id="业务要求"><a href="#业务要求" class="headerlink" title="业务要求"></a>业务要求</h2><ul>
<li>操作A操作数据库失败后，事务回滚，那么操作B不能执行。</li>
<li>操作A执行成功后，操作B也必须执行成功</li>
</ul>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ul>
<li>普通的执行A，之后执行B，是可以满足要求1，对于要求2通常需要设计补偿的操作</li>
<li>一般边缘的操作，通常会设置成为异步的，以提升性能，比如发送MQ，业务系统负责事务成功后消息发送成功，然后接收系统负责保证通知成功完成</li>
</ul>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="使用TransactionSynchronizationManager在事务提交之后操作"><a href="#使用TransactionSynchronizationManager在事务提交之后操作" class="headerlink" title="使用TransactionSynchronizationManager在事务提交之后操作"></a>使用TransactionSynchronizationManager在事务提交之后操作</h3><pre><code class="java">@Component
public class CallBackService &#123;

    public void execute(final CallBackAction action) &#123;

        if (TransactionSynchronizationManager.isActualTransactionActive()) &#123;
            TransactionSynchronizationManager
                    .registerSynchronization(new TransactionSynchronizationAdapter() &#123;
                        @Override
                        public void afterCommit() &#123;
                            // 事务提交后执行回调
                            action.callback();
                        &#125;
                    &#125;);
        &#125; else &#123;
            // 事务提交后执行回调
            action.callback();
        &#125;

    &#125;

&#125;
</code></pre>
<pre><code class="java">public interface CallBackAction &#123;
    /**
     * 普通事务回调
     */
    void callback();
&#125;
</code></pre>
<ul>
<li><p>有了上述两个类，就可以实现在一个事务提交后将消息发送到队列或是其他操作，具体操作如下</p>
</li>
<li><p>假设在一个业务下，往数据库插入了一条记录，然后向队列发送一条消息</p>
<pre><code class="java">@Override
@Transactional()
public void save() &#123;
    User user1 = new User();
    User user2 = new User();
    userMapper.insert(user1);
    userMapper.insert(user2);
    // 在事务提交后执行
    callBackService.execute(() -&gt; &#123;
        // ...
    &#125;);
&#125;
</code></pre>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #ff7d73">
                Java
            </a>
        </span>
        
    </div>
    <a href="/2022/09/02/SpringBoot事务提交后执行后续操作/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/02/Okhttp3证书请求/">
        <h2 class="post-title">OkHttp3使用证书发起请求</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/工作记录/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                工作记录
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <blockquote>
<p> 最近在对接微信支付功能，微信所有接口都采用okHttp3请求，但是申请退款接口需要证书才能调用，那如何使用证书发起请求以及证书如何获取，先看一下微信开发文档</p>
</blockquote>
<ol>
<li>在微信支付接口中，涉及资金回滚的接口会使用到API证书，包括退款、撤销接口。商家在申请微信支付成功后，收到的相应邮件后，可以按照指引下载API证书，也可以按照以下路径下载：微信商户平台(pay.weixin.qq.com)–&gt;账户中心–&gt;账户设置–&gt;API安全 。证书文件说明如下：</li>
</ol>
<table>
<thead>
<tr>
<th>证书附件</th>
<th>描述</th>
<th>使用场景</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>pkcs12格式(apiclient_cert.p12、</td>
<td>包含了私钥信息的证书文件，为p12(pfx)格式，由微信支付签发给您用来标识和界定您的身份</td>
<td>撤销、退款申请API中调用</td>
<td>windows上可以直接双击导入系统，导入过程中会提示输入证书密码，证书密码默认为您的商户ID（如：10010000）</td>
</tr>
</tbody></table>
<ul>
<li>以下两个证书在PHP环境中使用：</li>
</ul>
<table>
<thead>
<tr>
<th>证书附件</th>
<th>描述</th>
<th>使用场景</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>证书pem格式（apiclient_cert.pem）</td>
<td>从apiclient_cert.p12中导出证书部分的文件，为pem格式，请妥善保管不要泄漏和被他人复制</td>
<td>PHP等不能直接使用p12文件，而需要使用pem，为了方便您使用，已为您直接提供</td>
<td>您也可以使用openssl命令来自己导出：openssl pkcs12 -clcerts -nokeys -in apiclient_cert.p12 -out apiclient_cert.pem）</td>
</tr>
<tr>
<td>证书密钥pem格式（apiclient_key.pem）</td>
<td>从apiclient_key.pem中导出密钥部分的文件，为pem格式，请妥善保管不要泄漏和被他人复制</td>
<td>PHP等不能直接使用p12文件，而需要使用pem，为了方便您使用，已为您直接提供</td>
<td>您也可以使用openssl命令来自己导出：openssl pkcs12 -nocerts -in apiclient_cert.p12 -out apiclient_key.pem</td>
</tr>
</tbody></table>
<ol start="2">
<li>使用API证书<ul>
<li>apiclient_cert.p12是商户证书文件，除PHP外的开发均使用此证书文件。</li>
<li>商户如果使用.NET环境开发，请确认Framework版本大于2.0，必须在操作系统上双击安装证书apiclient_cert.p12后才能被正常调用。</li>
<li>API证书调用或安装需要使用到密码，该密码的值为微信商户号（mch_id）</li>
</ul>
</li>
<li>API证书安全<ul>
<li>证书文件不能放在web服务器虚拟目录，应放在有访问权限控制的目录中，防止被他人下载；</li>
<li>建议将证书文件名改为复杂且不容易猜测的文件名；</li>
<li>商户服务器要做好病毒和木马防护工作，不被非法侵入者窃取证书文件。</li>
</ul>
</li>
<li>商户回调API安全<ul>
<li>在普通的网络环境下，HTTP请求存在DNS劫持、运营商插入广告、数据被窃取，正常数据被修改等安全风险。商户回调接口使用HTTPS协议可以保证数据传输的安全性。所以微信支付建议商户提供给微信支付的各种回调采用HTTPS协议。</li>
</ul>
</li>
</ol>
<blockquote>
<p>以上就是微信对于API证书的说明，从微信商户平台上可以下载对应的证书，每个商户id都会对应一个证书，发起请求的时候需要使用对应的证书才可以</p>
</blockquote>
<ul>
<li><p>我们把证书文件 ***.p12文件发在 resource&#x2F;assets 目录下，创建带证书的OkHttpClient方法如下：</p>
<pre><code class="java">SSLContext sslContext = getSSLContextByAppKey(appKey);
if (sslContext == null) &#123;
    restLogger.info(&quot;获取证书失败&quot;);
    return null;
&#125;
OkHttpClient client = new OkHttpClient().newBuilder().sslSocketFactory(sslContext.getSocketFactory()).build();
</code></pre>
</li>
<li><p>获取SSLContext的方法如下：</p>
<pre><code class="java">private SSLContext getSSLContextByAppKey(String mchId) &#123;
    // 设置证书路径
    String certPath = String.format(&quot;assets/%s.p12&quot;, mchId);
    // 设置证书密码
    String certPass = mchId;
    // 获取证书
    return getSSLContext(certPath, certPass);
&#125;
private SSLContext getSSLContext(String certPath, String certPass) &#123;
    try &#123;
        KeyStore clientStore = KeyStore.getInstance(&quot;PKCS12&quot;);
        // 读取resource下的文件 支持jar方式启动
        Resource resource = new ClassPathResource(certPath);
        InputStream inputStream = resource.getInputStream();
        char[] passArray = certPass.toCharArray();
        clientStore.load(inputStream, passArray);
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(clientStore, passArray);
        KeyManager[] kms = kmf.getKeyManagers();
        SSLContext sslContext = SSLContext.getInstance(&quot;TLSv1&quot;);
        sslContext.init(kms, null, new SecureRandom());
        return sslContext;
    &#125; catch (Exception e) &#123;
        restLogger.info(&quot;设置证书出错&quot;);
    &#125;
    return null;
&#125;
</code></pre>
</li>
<li><p>按上述方式获取到的OkHttpClient就就能带着证书发起https请求了</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/OkHttp3/" style="color: #03a9f4">
                OkHttp3
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #ffa2c4">
                Java
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/WeChat/" style="color: #00a596">
                WeChat
            </a>
        </span>
        
    </div>
    <a href="/2022/09/02/Okhttp3证书请求/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/02/GuavaCache/">
        <h2 class="post-title">Guava Caches文档</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/文档/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                文档
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="Caches"><a href="#Caches" class="headerlink" title="Caches"></a>Caches</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumSize(1000)
       .expireAfterWrite(10, TimeUnit.MINUTES)
       .removalListener(MY_LISTENER)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             @Override
             public Graph load(Key key) throws AnyException &#123;
               return createExpensiveGraph(key);
             &#125;
           &#125;);
</code></pre>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p><strong>缓存用非常广泛的使用场景，例如，当一个变量需要耗费巨大的资源来计算或检索得到并且你不止一次需要用到这个变量，你就需要考虑使用缓存。</strong></p>
<p><em><strong>Cache</strong></em> 类似于  <em><strong>ConcurrentMap</strong></em>，但也不完全相同，最根本的区别就是 <em><strong>ConcurrentMap</strong></em> 会保留所有被存储的元素直到它们被移除，相反 <em><strong>Cache</strong></em> 为了限制自身的内存占用，通常会按配置好的方式自动清除键值对。在某些场景下 <em><strong>LoadingCache</strong></em> 由于可以自动加载缓存，即使不使用自动清除键值对，它也非常好用。</p>
<p><strong>通常来说guava cache工具适用于以下一些场景：</strong></p>
<ul>
<li><strong>你想使用一些内存空间来改善程序运行速度</strong></li>
<li><strong>一些keys会被多次使用</strong></li>
<li><strong>你的缓存相对于机器内存来说占用量不是特别大（guava cache属于本地缓存，它是运行在单机应用上的，它不会把缓存存储到文件或其他服务器上面。如果这些不满足的需求，你需要考虑其他缓存工具比如</strong><a target="_blank" rel="noopener" href="http://memcached.org/"><em><strong>Memcached</strong></em></a>）</li>
</ul>
<p><strong>如果以上全部满足你的使用场景，那么guava cache工具将非常适合你！</strong></p>
<p>获得一个 <em><strong>Cache</strong></em> 对象只需要像示例中一样通过 <em><strong>CacheBuilder</strong></em> 的建造者模式创建，但是定制化你自己的 <em><strong>Cache</strong></em> 对象才是有意思的部分</p>
<p><strong>Note:如果你不需要使用 <em><strong>Cache</strong></em> 的特性，那么 <em><strong>ConcurrentHashMap</strong></em> 将更省内存，但是在任何老的 <em><strong>ConcurrentMap</strong></em> 上实现 <em><strong>Cache</strong></em> 的特性是非常困难甚至不可能的。</strong></p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p><strong>第一个关于缓存的问题便是，是否存在一个好用的默认方法来加载或计算一个key的值，如果有的话，你应该使用 <em><strong>CacheLoader</strong></em> 对象，如果没有或者说你需要重写这个默认方法，但是仍然想要一个满足”get-if-absent-compute”语法的原子操作，你应该在 <em><strong>get()</strong></em> 方法中传入一个 <em><strong>Callable</strong></em> 对象。使用 <em><strong>Cache.put</strong></em> 方法可以使元素立刻加入到缓存中去，但是自动化缓存加载更好是因为它更容易解决缓存内容一致性的问题。</strong></p>
<h5 id="使用CacheLoader"><a href="#使用CacheLoader" class="headerlink" title="使用CacheLoader"></a>使用CacheLoader</h5><p><em><strong>LoadingCache</strong></em> 是一个 <em><strong>Cache</strong></em> 在build中附带了一个<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html"><em><strong>CacheLoader</strong></em></a>。创建一个 <em><strong>CacheLoader</strong></em> 对象并实现 <em><strong>V load(K key) throws Exception</strong></em> 方法非常简单。因此，你可以用以下方式创建一个 <em><strong>LoadingCache</strong></em> 对象：</p>
<pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumSize(1000)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) throws AnyException &#123;
               return createExpensiveGraph(key);
             &#125;
           &#125;);
...
try &#123;
  return graphs.get(key);
&#125; catch (ExecutionException e) &#123;
  throw new OtherException(e.getCause());
&#125;
</code></pre>
<p><strong>典型的查询 <em><strong>LoadingCache</strong></em> 的方式是使用 <em><strong>get(k)</strong></em> 方法，这将会返回一个已经存在的缓存值，或者使用 <em><strong>CacheLoader</strong></em> 自动加载一个新的值到缓存中去。由于 <em><strong>CacheLoader</strong></em> 可能会抛出一个 <em><strong>Exception</strong></em> ，因此 <em><strong>LoadingCache.get(K)</strong></em> 会抛出  <em><strong>ExecutionException</strong></em></strong> （如果 <em><strong>CacheLoader</strong></em> 抛出的是非受检异常， <em><strong>get(k)</strong></em> 方法将会抛出 <em><strong>UncheckedExecutionException</strong></em> 来替换）。你也可以选择使用 <em><strong>getUnchecked(K)</strong></em> 方法，它会把所有异常都替换成 <em><strong>UncheckedExecutionException</strong></em> ，但是如果底层的 <em><strong>CacheLoader</strong></em> 抛出受检异常可能会导致一些意外的情况。</p>
<pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .expireAfterAccess(10, TimeUnit.MINUTES)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) &#123; // no checked exception
               return createExpensiveGraph(key);
             &#125;
           &#125;);
...
return graphs.getUnchecked(key);
</code></pre>
<p><strong>批量查找可以使用 <em><strong>getAll(Iterable&lt;? extends K&gt;)</strong></em> 方法。</strong> 在默认情况下， <em><strong>getAll</strong></em> 方法会对每个不存在于缓存中的key轮流调用 <em><strong>CacheLoader.load</strong></em> 方法。当批量检索比多个单次查询效率更高时，你可以重写 <em><strong>CacheLoader.loadAll</strong></em> 方法来开发这个功能， <em><strong>getAll(Iterable)</strong></em> 方法的性能将会有显著改善。 记住你可以重写 <em><strong>CacheLoader.loadAll</strong></em> 方法来批量加载缓存。例如：XXX</p>
<h5 id="关于Callable"><a href="#关于Callable" class="headerlink" title="关于Callable"></a>关于Callable</h5><p><strong>所有guava cache对象，不管用没有加载过数据，都支持 <em><strong>get(K, Callable)</strong></em> 方法，这个方法会返回缓存中已存在key值，若不存在，将会调用实现好的 <em><strong>Callable</strong></em> 方法来将值加载到缓存中。没有规定声明缓存在加载完成前不会被修改，这个方法提供了一个简单可替代的通俗模式“缓存存在即返回，不存在则创建”。</strong></p>
<pre><code class="java">Cache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder()
    .maximumSize(1000)
    .build(); // look Ma, no CacheLoader
...
try &#123;
  // If the key wasn&#39;t in the &quot;easy to compute&quot; group, we need to
  // do things the hard way.
  cache.get(key, new Callable&lt;Value&gt;() &#123;
    @Override
    public Value call() throws AnyException &#123;
      return doThingsTheHardWay(key);
    &#125;
  &#125;);
&#125; catch (ExecutionException e) &#123;
  throw new OtherException(e.getCause());
&#125;
</code></pre>
<h5 id="直接插入缓存"><a href="#直接插入缓存" class="headerlink" title="直接插入缓存"></a>直接插入缓存</h5><p><strong>通过 <em><strong>cache.put(key, value)</strong></em> 方法可以直接将变量插入到缓存</strong>，这个操作会覆盖缓存中已存在key，变化后的值可以通过 <em><strong>Cache.asMap()</strong></em> 暴露出来的 <em><strong>ConcurrentMap</strong></em> 访问。需要注意的是 <em><strong>asMap</strong></em> 方法返回的对象不存在某个方法可以使数据自动加载到缓存。因此，在使用了 <em><strong>CacheLoader</strong></em> 或 <em><strong>Callable</strong></em> 实现的Cache中， <em><strong>Cache.get(K, Callable)</strong></em> 方法总是比 <em><strong>Cache.asMap().putIfAbsent</strong></em> 方法更好</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p><strong>然而冷酷无情的现实便是我们总是没有足够的内存去缓存所有的东西，你必须要考虑好，一个缓存的键值对何时不再需要。Guava提供了三种基本类型的缓存回收，基于空间回收，基于时间回收，基于引用回收。</strong></p>
<h4 id="基于空间回收"><a href="#基于空间回收" class="headerlink" title="基于空间回收"></a>基于空间回收</h4><p><strong>如果你的缓存不会超过一个具体的大小，使用</strong><a target="_blank" rel="noopener" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#maximumSize-long-"><em><strong>CacheBuilder.maximumSize(long)</strong></em></a> 来设置缓存最大存储空间，缓存将会自动尝试去回收一些不常用的键值对。警告：在最大缓存空间溢出之前，缓存就有可能会去回收键值对，尤其是快要溢出的时候。</p>
<p><strong>如果不同的缓存键值对有不同的“weights”，比如你的缓存键值对占用的内存空间截然不同——你可以具体实现一个</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weigher-com.google.common.cache.Weigher-"><em><strong>CacheBuilder.weigher(Weigher)</strong></em></a> 方法，并且设置 <em><strong>CacheBuilder.maximumWeight(long)</strong></em> 属性。除了 <em><strong>maximumSize</strong></em> 要求的警告事项之外，你需要注意weights是在键值对创建时就计算得出了，并且计算得出后不再变化。</p>
<pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumWeight(100000)
       .weigher(new Weigher&lt;Key, Graph&gt;() &#123;
          public int weigh(Key k, Graph g) &#123;
            return g.vertices().size();
          &#125;
        &#125;)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) &#123; // no checked exception
               return createExpensiveGraph(key);
             &#125;
           &#125;);
</code></pre>
<h4 id="基于时间回收"><a href="#基于时间回收" class="headerlink" title="基于时间回收"></a>基于时间回收</h4><p><em><strong>CacheBuilder</strong></em> 提供了两种处理方式来实现时间回收：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#expireAfterAccess-long-java.util.concurrent.TimeUnit-"><em><strong>expireAfterAccess(long, TimeUnit)</strong></em></a> 一个键值对在最后一次读取后写入后经过指定的时间间隔就会被回收。需要注意的是键值对的回收顺序和基于空间回收的逻辑相似。</li>
<li><a target="_blank" rel="noopener" href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#expireAfterWrite-long-java.util.concurrent.TimeUnit-"><em><strong>expireAfterWrite(long, TimeUnit)</strong></em></a> 当一个键值对被创建或被重新写入的是开始计时，指定时间之后被回收。如果缓存数据每过一段时间就需要被淘汰的话就非常适合使用这种方式。</li>
</ul>
<h5 id="测试时间回收"><a href="#测试时间回收" class="headerlink" title="测试时间回收"></a>测试时间回收</h5><p><strong>测试时间回收并不是一件很痛苦的事情，因为你并不需要花费两秒钟的时间来等待一个设置了两秒过期的缓存。使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Ticker.html"><em><strong>Ticker</strong></em></a>接口和<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#ticker-com.google.common.base.Ticker-"><em><strong>CacheBuilder.ticker(Ticker)</strong></em></a> 方法来指定一个时间源，而不是去等待系统时钟。</p>
<h4 id="基于引用回收"><a href="#基于引用回收" class="headerlink" title="基于引用回收"></a>基于引用回收</h4><p><strong>Guava允许你使用GC机制来回收缓存，对keys或values使用</strong><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html"><em><strong>weak references</strong></em></a>，对values使用<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html"><em><strong>soft references</strong></em></a>。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weakKeys--"><em><strong>CacheBuilder.weakKeys()</strong></em></a> 对keys使用弱引用，当没有其他对keys的强引用和软引用时，该键值对可以被GC。 符号来比较keys之间的相等，而不是 <em><strong>equals()</strong></em> 。</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weakValues--"><em><strong>CacheBuilder.weakValues()</strong></em></a> 对values使用弱引用，当没有其他对values的强引用和软引用时，该键值对可以被GC。</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#softValues--"><em><strong>CacheBuilder.softValues()</strong></em></a> 用软引用的方式覆盖values，按照内存要求，软引用对象在全局least-recently-used方式下可以被GC。因为使用软引用的性能暗示，我通常推荐使用可预测性更好的<a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/CachesExplained#Size-based-Eviction"><em><strong>maximum cache size</strong></em></a>，使用 <em><strong>softValues()</strong></em> 会导致values之间的比较会使用 <em><strong>(&#x3D;&#x3D;)</strong></em> 符号而不是 <em><strong>equals()</strong></em> 。</li>
</ul>
<h4 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h4><p><strong>在任何时候，你可能明确知道要删除缓存而不是等待缓存被回收，以下可以实现：</strong></p>
<ul>
<li><strong>删除单个缓存，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#invalidate-java.lang.Object-"><em><strong>Cache.invalidate(key)</strong></em></a></li>
<li><strong>批量删除缓存，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#invalidateAll-java.lang.Iterable-"><em><strong>Cache.invalidateAll(keys)</strong></em></a></li>
<li><strong>删除全部缓存，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#invalidateAll--"><em><strong>Cache.invalidateAll()</strong></em></a></li>
</ul>
<h4 id="缓存删除监听器"><a href="#缓存删除监听器" class="headerlink" title="缓存删除监听器"></a>缓存删除监听器</h4><p><strong>你可以实现一个缓存删除监听器在缓存被删除的时候完成一些操作，通过</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#removalListener-com.google.common.cache.RemovalListener-"><em><strong>CacheBuilder.removalListener(RemovalListener)</strong></em></a> 注册监听器。<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalListener.html"><em><strong>RemovalListener</strong></em></a>传入一个<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalNotification.html"><em><strong>RemovalNotification</strong></em></a>参数，它详细指定了<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalCause.html">RemovalCause</a>，key和value。 需要注意的是 <em><strong>RemovalListener</strong></em> 抛出的所有异常都会被吞掉并用Logger打印。</p>
<pre><code class="java">CacheLoader&lt;Key, DatabaseConnection&gt; loader = new CacheLoader&lt;Key, DatabaseConnection&gt; () &#123;
  public DatabaseConnection load(Key key) throws Exception &#123;
    return openConnection(key);
  &#125;
&#125;;
RemovalListener&lt;Key, DatabaseConnection&gt; removalListener = new RemovalListener&lt;Key, DatabaseConnection&gt;() &#123;
  public void onRemoval(RemovalNotification&lt;Key, DatabaseConnection&gt; removal) &#123;
    DatabaseConnection conn = removal.getValue();
    conn.close(); // tear down properly
  &#125;
&#125;;
return CacheBuilder.newBuilder()
  .expireAfterWrite(2, TimeUnit.MINUTES)
  .removalListener(removalListener)
  .build(loader);
</code></pre>
<p> <strong>警告</strong> <strong>：缓存删除监听器默认情况下是同步执行的，当缓存维护器在正常执行时，缓存删除监听器的可能会拖慢你的缓存使用！如果你的缓存删除监听器效率不是很高，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalListeners.html#asynchronous-com.google.common.cache.RemovalListener-java.util.concurrent.Executor-"><em><strong>RemovalListeners.asynchronous(RemovalListener, Executor)</strong></em></a> 来装饰 <em><strong>RemovalListener</strong></em> 实现异步操作。</p>
<h4 id="缓存是何时清除的"><a href="#缓存是何时清除的" class="headerlink" title="缓存是何时清除的"></a>缓存是何时清除的</h4><p><em><strong>CacheBuilder</strong></em> 创建的 <em><strong>Caches</strong></em> 对象不会“自动”清除缓存中的值。只有在写入操作时才会有少数维护操作，当写入操作较少时，会在偶然的读取操作时触发。 原因如下：如果我们想让 <em><strong>Caches</strong></em> 连续不断地去维护，我们需要创建一个线程，并且它的操作可能会和用户的操作去竞争锁。此外，一些环境会限制线程的创建，这会使得 <em><strong>CacheBuilder</strong></em> 在这些环境下不可用。 我们把选择权交给了你，如果你的缓存吞吐量很高，那你不需要担心缓存维护去执行对过期键值对的清除。如果你的缓存很少有写入操作，并且不希望缓存清除导致读取阻塞，你可以去创建你自己的维护线程定时调用 <a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/11.0.1/api/docs/com/google/common/cache/Cache.html#cleanUp--"><em><strong>Cache.cleanUp()</strong></em></a> 方法。 如果你想对一个写入频率较少的缓存定时使用缓存维护，可以使用 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html"><em><strong>ScheduledExecutorService</strong></em></a></p>
<h4 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h4><p><strong>缓存刷新和缓存回收不太一样</strong>，在<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/LoadingCache.html#refresh-K-"><em><strong>LoadingCache.refresh(K)</strong></em></a> 这个方法的文档中，刷新一个key的值会往缓存中加载一个新的value，这个操作是可以异步的。缓存刷新的同时，老的value会被该方法返回。 如果刷新缓存的过程中抛出异常，那么老的value将被保留，同时该异常会被吞掉并通过logger打印出来。 重写 <em><strong>CacheLoader</strong></em> 的 <a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html#reload-K-V-"><em><strong>CacheLoader.reload(K, V)</strong></em></a> 方法可以实现缓存刷新操作，这个方法允许你使用老value来计算出新的value。</p>
<pre><code class="java">// Some keys don&#39;t need refreshing, and we want refreshes to be done asynchronously.
LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumSize(1000)
       .refreshAfterWrite(1, TimeUnit.MINUTES)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) &#123; // no checked exception
               return getGraphFromDatabase(key);
             &#125;
             public ListenableFuture&lt;Graph&gt; reload(final Key key, Graph prevGraph) &#123;
               if (neverNeedsRefresh(key)) &#123;
                 return Futures.immediateFuture(prevGraph);
               &#125; else &#123;
                 // asynchronous!
                 ListenableFutureTask&lt;Graph&gt; task = ListenableFutureTask.create(new Callable&lt;Graph&gt;() &#123;
                   public Graph call() &#123;
                     return getGraphFromDatabase(key);
                   &#125;
                 &#125;);
                 executor.execute(task);
                 return task;
               &#125;
             &#125;
           &#125;);
</code></pre>
<p><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#refreshAfterWrite-long-java.util.concurrent.TimeUnit-"><em><strong>CacheBuilder.refreshAfterWrite(long, TimeUnit)</strong></em></a> 方法可以实现缓存自动定时刷新。和 <em><strong>expireAfterWrite</strong></em> 方法不同的是，<em><strong>refreshAfterWrite</strong></em> 会使得key在指定时间后进行刷新，但实际上缓存刷新只会在键值对被查询时被触发（如果 <em><strong>CacheLoader.reload</strong></em> 方法时异步实现的，那查询不会因为刷新变得更慢）。例如，你同时设置了 <em><strong>refreshAfterWrite</strong></em> 和 <em><strong>expireAfterWrite</strong></em> ，那么这种情况下，就算这个键值对满足刷新条件，它的过期时间也不会被重置，因此当一个键值对满足刷新条件但没有被查询的话，它依然允许被回收。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/12.0/api/docs/com/google/common/cache/CacheBuilder.html#recordStats--"><em><strong>CacheBuilder.recordStats()</strong></em></a> 可以打开guava cache的数据收集功能， <a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#stats--"><em><strong>Cache.stats()</strong></em></a> 返回一个<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html"><em><strong>CacheStats</strong></em></a> 对象，它能提供以下数据统计：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html#hitRate--"><em><strong>hitRate()</strong></em></a> 返回查询请求的命中率</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html#averageLoadPenalty--"><em><strong>averageLoadPenalty()</strong></em></a> 加载新value的平均时间，单位：纳秒</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html#evictionCount--"><em><strong>evictionCount()</strong></em></a> 缓存回收的次数 除此之外还有许多其他的数据统计项，这些统计信息对于缓存调整至关重要，我们建议在性能要求较高的应用中多多注意这些数据指标。</li>
</ul>
<h4 id="asMap"><a href="#asMap" class="headerlink" title="asMap"></a>asMap</h4><p><strong>你可以使用 <em><strong>asMap</strong></em> 将任何一个 <em><strong>Cache</strong></em> 对象视为 <em><strong>ConcurrentMap</strong></em> ，但是 <em><strong>asMap</strong></em> 如何影响 <em><strong>Cache</strong></em> 这里需要解释：</strong></p>
<ul>
<li><em><strong>cache.asMap()</strong></em> 包含缓存中目前存储的所有键值对，因此例如：<em><strong>cache.asMap().keySet()</strong></em> 包含缓存中所有的keys</li>
<li><em><strong>asMap().get(key)</strong></em> 本质上等同于 <em><strong>cache.getIfPresent(key)</strong></em> ，不会使得value被加载到缓存。这和 <em><strong>Map</strong></em> 的协议一致</li>
<li><strong>缓存的访问时间会被任何读取和写入操作重置</strong>（包括 <em><strong>Cache.asMap().get(Object)</strong></em> 和 <em><strong>Cache.asMap().put(K, V)</strong></em> ），但是不包括 <em><strong>containsKey(Object)</strong></em> ，也不包括 <em><strong>Cache.asMap()</strong></em> 。因此比如：通过 <em><strong>cache.asMap().entrySet()</strong></em> 迭代键值对不会重置缓存的访问时间</li>
</ul>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><strong>参考：</strong><a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/CachesExplained"><em><strong>https://github.com/google/guava/wiki/CachesExplained</strong></em></a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #ff7d73">
                Java
            </a>
        </span>
        
    </div>
    <a href="/2022/09/02/GuavaCache/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/08/31/红黑树/">
        <h2 class="post-title">红黑树</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/算法/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/31
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <!-- ![img](../images/红黑树/kangna01.jpg) -->

<pre><code class="java">public class RBMap &#123;

    private Node root = null;

    private int minDepth = Integer.MAX_VALUE;

    private int maxDepth = 0;

    private int maxBlackCnt = 0;

    public void put(Integer value) &#123;
        Node node = new Node(value);
        // 从根节点向下查找到合适的位置并添加
        setValue2Tree(node, root);
        // 平衡
        balanceTree(node);
    &#125;

    public boolean exist(Integer value) &#123;
        return findValueInTree(value, root);
    &#125;

    public void printTree() &#123;
        printNode(root);
    &#125;

    public int getDepthDiffer() &#123;
        getDepth(root, 0);
        return maxDepth = minDepth;
    &#125;

    /**
     * 红黑树形状检测
     * @return
     */
    public boolean checkRBStruct() &#123;
        if (root.red) &#123;
            return false;
        &#125;
        // 检测是否存在相连的红色节点
        boolean redNotLink = checkRedNotLink(root);
        // 计算每个路径上的黑色节点数量是否相同
        maxBlackCnt = 0;
        boolean checkBlackCnt = checkBlackCnt(root, 0);
        return redNotLink &amp;&amp; checkBlackCnt;
    &#125;

    /**
     * 先将节点加入树
     * @param node
     * @param father
     */
    private void setValue2Tree(Node node, Node father) &#123;
        if (father == null) &#123;
            root = node;
            return;
        &#125;
        if (node.value &lt; father.value) &#123;
            if (father.left == null) &#123;
                father.left = node;
                node.father = father;
            &#125; else &#123;
                setValue2Tree(node, father.left);
            &#125;
        &#125; else if (node.value &gt; father.value) &#123;
            if (father.right == null) &#123;
                father.right = node;
                node.father = father;
            &#125; else &#123;
                setValue2Tree(node, father.right);
            &#125;
        &#125; else &#123;
            // 更新节点值即可，当前情况不需要其他操作

        &#125;
    &#125;

    /**
     * 平衡这棵树
     */
    private void balanceTree(Node node) &#123;
        if (node.father == null) &#123;
            // node是根节点，直接变成黑色
            node.red = false;
        &#125;
        // node的father是黑色的，不需要调整
        Node father = node.father;
        if (father != null &amp;&amp; !father.red) &#123;
            return;
        &#125;
        // node的father是红色
        if (father != null &amp;&amp; father.red) &#123;
            // father肯定还有father，找到grandFather
            Node grandFather = father.father;
            Node uncle = father == grandFather.left ? grandFather.right : grandFather.left;
            // 找到grandFather是否还有另一个儿子，即是否有uncle
            if (uncle != null &amp;&amp; uncle.red) &#123;
                // uncle是红色的，现将father和uncle变成黑色，grandFather变成红色
                father.red = false;
                uncle.red = false;
                grandFather.red = true;
                // 由于grandFather变成红色了，可以理解为此时grandFather也是新加入树的一个叶子节点，从这个节点再次平衡
                balanceTree(grandFather);
            &#125; else &#123;
                // 没有uncle，或者uncle是黑色
                Node brother = node == father.left ? father.right : father.left;
                if (father == grandFather.left &amp;&amp; node == father.left) &#123;
                    // LL 情况，先变色，再旋转
                    processLL(father, grandFather, brother);
                &#125; else if (father == grandFather.left &amp;&amp; node == father.right) &#123;
                    // LR 情况，将node和father交换变成LL
                    processLR(node, father, grandFather);
                &#125; else if (father == grandFather.right &amp;&amp; node == father.right) &#123;
                    // RR 情况，和LL对称
                    processRR(father, grandFather, brother);
                &#125; else if (father == grandFather.right &amp;&amp; node == father.left) &#123;
                    // RL 情况，和LR对称
                    processRL(node, father, grandFather);
                &#125;
                // 旋转后更新root
                if (root == grandFather &amp;&amp; grandFather.father != null) &#123;
                    root = grandFather.father;
                &#125;
            &#125;
        &#125;
    &#125;

    private void processLL(Node father, Node grandFather, Node brother) &#123;
        father.red = false;
        grandFather.red = true;
        father.father = grandFather.father;
        if (grandFather.father != null) &#123;
            if (grandFather.father.left == grandFather) &#123;
                grandFather.father.left = father;
            &#125; else &#123;
                grandFather.father.right = father;
            &#125;
        &#125;
        father.right = grandFather;
        grandFather.father = father;
        grandFather.left = brother;
        if (brother != null) &#123;
            brother.father = grandFather;
        &#125;
    &#125;

    private void processRR(Node father, Node grandFather, Node brother) &#123;
        father.red = false;
        grandFather.red = true;
        father.father = grandFather.father;
        if (grandFather.father != null) &#123;
            if (grandFather.father.left == grandFather) &#123;
                grandFather.father.left = father;
            &#125; else &#123;
                grandFather.father.right = father;
            &#125;
        &#125;
        father.left = grandFather;
        grandFather.father = father;
        grandFather.right = brother;
        if (brother != null) &#123;
            brother.father = grandFather;
        &#125;
    &#125;

    private void processLR(Node node, Node father, Node grandFather) &#123;
        grandFather.left = node;
        node.father = grandFather;
        father.right = node.left;
        if (father.right != null) &#123;
            father.right.father = father;
        &#125;
        node.left = father;
        father.father = node;
        processLL(node, grandFather, node.right);
    &#125;

    private void processRL(Node node, Node father, Node grandFather) &#123;
        grandFather.right = node;
        node.father = grandFather;
        father.left = node.right;
        if (father.left != null) &#123;
            father.left.father = father;
        &#125;
        node.right = father;
        father.father = node;
        processRR(node, grandFather, node.left);
    &#125;

    private boolean findValueInTree(int value, Node node) &#123;
        if (node == null) &#123;
            return false;
        &#125;
        if (value == node.value) &#123;
            return true;
        &#125;
        if (value &lt; node.value) &#123;
            return findValueInTree(value, node.left);
        &#125; else &#123;
            return findValueInTree(value, node.right);
        &#125;
    &#125;

    private void printNode(Node node) &#123;
        if (node == null) &#123;
            return;
        &#125;
        String left = node.left != null ? node.left.value + &quot;&quot; : &quot;null&quot;;
        String right = node.right != null ? node.right.value + &quot;&quot; : &quot;null&quot;;
        String father = node.father != null ? node.father.value + &quot;&quot; : &quot;null&quot;;
        System.out.println(&quot;(&quot; + node.value + &quot; &quot; + (node.red ? &quot;R&quot; : &quot;B&quot;) + &quot; &quot; + left + &quot; &quot; + right + &quot; | &quot; + father + &quot;)&quot;);
        printNode(node.left);
        printNode(node.right);
    &#125;

    private void getDepth(Node node, int depth) &#123;
        if (node == null) &#123;
            if (depth &lt; minDepth) &#123;
                minDepth = depth;
            &#125;
            if (depth &gt; maxDepth) &#123;
                maxDepth = depth;
            &#125;
            return;
        &#125;
        getDepth(node.left, depth + 1);
        getDepth(node.right, depth + 1);
    &#125;

    private boolean checkRedNotLink(Node node) &#123;
        if (node.left != null &amp;&amp; node.right != null) &#123;
            if (node.red &amp;&amp; node.left.red || node.red &amp;&amp; node.right.red) &#123;
                return false;
            &#125; else &#123;
                return checkRedNotLink(node.left) &amp;&amp; checkRedNotLink(node.right);
            &#125;
        &#125; else if (node.left != null) &#123;
            if (node.red &amp;&amp; node.left.red) &#123;
                return false;
            &#125; else &#123;
                return checkRedNotLink(node.left);
            &#125;
        &#125; else if (node.right != null) &#123;
            if (node.red &amp;&amp; node.right.red) &#123;
                return false;
            &#125; else &#123;
                return checkRedNotLink(node.right);
            &#125;
        &#125;
        return true;
    &#125;

    private boolean checkBlackCnt(Node node, int currentCnt) &#123;
        if (!node.red) &#123;
            currentCnt ++;
        &#125;
        if (node.left == null &amp;&amp; node.right == null) &#123;
            if (maxBlackCnt &lt;= 0) &#123;
                maxBlackCnt = currentCnt;
                return true;
            &#125; else if (currentCnt != maxBlackCnt) &#123;
                return false;
            &#125;
        &#125; else if (node.left != null) &#123;
            return checkBlackCnt(node.left, currentCnt);
        &#125; else &#123;
            return checkBlackCnt(node.right, currentCnt);
        &#125;
        return true;
    &#125;

    private static class Node &#123;
        public boolean red = true;
        public Integer value;
        public Node left;
        public Node right;
        public Node father;

        public Node(Integer value) &#123;
            this.value = value;
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Java/" style="color: #00bcd4">
                Java
            </a>
        </span>
        
    </div>
    <a href="/2022/08/31/红黑树/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
    </div>
    <div class="next">
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/NatureRan/Images/main/benghuai11-headImg.jpg " alt="avatar">
        </div>
        <div class="name">
            Nature
        </div>
        <div class="descriptions">
            
            <div class="description">
                hesitation is defeat
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/natureran">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 NatureRan
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Nature
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>