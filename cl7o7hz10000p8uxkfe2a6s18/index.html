
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>03、Docker基础理论 | NatureRan</title>
        <meta name="author" content="Nature">
        <meta name="description" content="">
        <meta name="keywords" content="java">
        <link rel="icon" href="https://raw.githubusercontent.com/NatureRan/Images/main/benghuai11-headImg.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">NatureRan</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NatureRan</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>03、Docker基础理论 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Docker/" style="color: #ffa2c4">
                    Docker
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <font color='red' size=5>
容器的本质是一种特殊的进程
</font>

<p><strong>是一个受Linux中Namespace和Cgropes隔离和限制作用的进程</strong></p>
<span id="more"></span>

<h1 id="1、Namespace技术"><a href="#1、Namespace技术" class="headerlink" title="1、Namespace技术"></a>1、Namespace技术</h1><p><strong>尝试在linux中创建一个进程</strong></p>
<p><strong>创建进程使用</strong>clone函数<strong>，正常情况下创建一个进程如下所示，main_function就是新建进程中需要执行的函数。</strong></p>
<pre><code class="C">int pid = clone(main_function, stack_size, SIGCHLD, NULL); 
</code></pre>
<p><strong>使用Namespace方式创建进程只需要多加一个参数 CLONE_NEWPID：</strong></p>
<pre><code class="C">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
</code></pre>
<p><strong>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</strong></p>
<p><strong>而除了刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</strong></p>
<p><strong>完整代码如下：</strong></p>
<pre><code class="C">#define _GNU_SOURCE
#include &lt;sys/mount.h&gt; 
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];
char* const container_args[] = &#123;
  &quot;/bin/bash&quot;,
  NULL
&#125;;

int container_main(void* arg)
&#123;  
  printf(&quot;Container - inside the container!\n&quot;);
  execv(container_args[0], container_args);
  printf(&quot;Something&#39;s wrong!\n&quot;);
  return 1;
&#125;

int main()
&#123;
  printf(&quot;Parent - start a container!\n&quot;);
  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , NULL);
  waitpid(container_pid, NULL, 0);
  printf(&quot;Parent - container stopped!\n&quot;);
  return 0;
&#125;
</code></pre>
<p><strong>这段代码的功能非常简单：在 main 函数里，通过 clone() 系统调用创建了一个新的子进程 container_main，并且声明要为它启用 Mount Namespace（即：CLONE_NEWNS 标志）。</strong></p>
<p><strong>而这个子进程执行的，是一个“&#x2F;bin&#x2F;bash”程序，也就是一个 shell。</strong></p>
<p><strong>所以这个 shell 就运行在了 Mount Namespace 的隔离环境中。</strong></p>
<p><strong>尝试编译运行这段代码</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z linux]# ls
new_progress.c
[root@iZbp1c0sait1zv807y3ok5Z linux]# gcc -o new_progress new_progress.c 
[root@iZbp1c0sait1zv807y3ok5Z linux]# ls
new_progress  new_progress.c
[root@iZbp1c0sait1zv807y3ok5Z linux]# ./new_progress 
Parent - start a container!
Container - inside the container!
[root@iZbp1c0sait1zv807y3ok5Z linux]# ls /tmp
systemd-private-63160db9a84244739b18d8eeb2e90804-chronyd.service-6Kv0zf  systemd-private-63160db9a84244739b18d8eeb2e90804-mysqld.service-lBl3ri
[root@iZbp1c0sait1zv807y3ok5Z linux]# exit
exit
Parent - container stopped!
[root@iZbp1c0sait1zv807y3ok5Z linux]# ls /tmp
systemd-private-63160db9a84244739b18d8eeb2e90804-chronyd.service-6Kv0zf  systemd-private-63160db9a84244739b18d8eeb2e90804-mysqld.service-lBl3ri
[root@iZbp1c0sait1zv807y3ok5Z linux]# 
</code></pre>
<p><strong>看到第7,8行的输出后，其实控制台已经在一个新的bash里面了，可以看到执行了一次exit，正常输出Parent - container stopped! 并且在容器里和外面，看到的&#x2F;tmp目录下的文件是完全相同的。</strong></p>
<p><strong>也就是说：</strong></p>
<p><strong>即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。</strong></p>
<p><strong>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知。但是，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。</strong></p>
<p><strong>所以在创建新进程时，除了声明要启用 Mount Namespace 之外，还可以告诉容器进程，有哪些目录需要重新挂载，就比如这个 &#x2F;tmp 目录。于是，我们在容器进程执行前可以添加一步重新挂载 &#x2F;tmp 目录的操作：</strong></p>
<pre><code class="C">int container_main(void* arg)
&#123;
    printf(&quot;Container - inside the container!\n&quot;);
    // 如果你的机器的根目录的挂载类型是shared，那必须先重新挂载根目录
    // mount(&quot;&quot;, &quot;/&quot;, NULL, MS_PRIVATE, &quot;&quot;);
    mount(&quot;none&quot;, &quot;/tmp&quot;, &quot;tmpfs&quot;, 0, &quot;&quot;);
    execv(container_args[0], container_args);
    printf(&quot;Something&#39;s wrong!\n&quot;);
    return 1;
&#125;
</code></pre>
<p><strong>mount(“none”, “&#x2F;tmp”, “tmpfs”, 0, “”);语句告诉了容器以 tmpfs（内存盘）格式，重新挂载了 &#x2F;tmp 目录。</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z linux]# gcc -o new_progress new_progress.c 
[root@iZbp1c0sait1zv807y3ok5Z linux]# ./new_progress 
Parent - start a container!
Container - inside the container!
[root@iZbp1c0sait1zv807y3ok5Z linux]# ls /tmp
[root@iZbp1c0sait1zv807y3ok5Z linux]# 
</code></pre>
<p><strong>可以看到，这次 &#x2F;tmp 变成了一个空目录，这意味着重新挂载生效了。我们可以用 mount -l 检查一下：</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z linux]# mount -l | grep tmpfs
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
devtmpfs on /dev type devtmpfs (rw,nosuid,size=988852k,nr_inodes=247213,mode=755)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run type tmpfs (rw,nosuid,nodev,mode=755)
tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=201628k,mode=700)
none on /tmp type tmpfs (rw,relatime)
[root@iZbp1c0sait1zv807y3ok5Z linux]# 
</code></pre>
<p><strong>第7行显示的 &#x2F;tmp 确实已经是tmpfs的了，此时退出容器后，从宿主机中看是没有&#x2F;tmp挂载的。（然而实际操作看还是有，不知道是什么情况了）</strong></p>
<p><strong>这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</strong></p>
<p><strong>所以每当创建一个新容器时，都希望容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统。怎么才能做到这一点呢？不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“&#x2F;”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</strong></p>
<p><strong>当然，为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls &#x2F;“ 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</strong></p>
<p><strong>另外，需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所以说，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。</strong></p>
<p><strong>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核。</strong></p>
<p><strong>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</strong></p>
<h1 id="2、Linux-Cgroups"><a href="#2、Linux-Cgroups" class="headerlink" title="2、Linux Cgroups"></a>2、Linux Cgroups</h1><p><strong>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</strong></p>
<p><strong>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 &#x2F;sys&#x2F;fs&#x2F;cgroup 路径下。</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z ~]# mount -t cgroup
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
[root@iZbp1c0sait1zv807y3ok5Z ~]# 
</code></pre>
<p><strong>它的输出结果，是一系列文件系统目录。如果你在自己的机器上没有看到这些目录，那你就需要自己去挂载 Cgroups。</strong></p>
<p><strong>可以看到，在 &#x2F;sys&#x2F;fs&#x2F;cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z ~]# ls /sys/fs/cgroup/cpu
aegis                  cpuacct.cgroup_wait_latency   cpuacct.usage              cpuacct.usage_user      cpu.cfs_quota_us   release_agent
assist                 cpuacct.enable_sli            cpuacct.usage_all          cpuacct.wait_latency    cpu.identity       system.slice
cgroup.clone_children  cpuacct.ioblock_latency       cpuacct.usage_percpu       cpu.bvt_warp_ns         cpu.shares         tasks
cgroup.procs           cpuacct.proc_stat             cpuacct.usage_percpu_sys   cpu.cfs_burst_us        cpu.stat           user.slice
cgroup.sane_behavior   cpuacct.sched_cfs_statistics  cpuacct.usage_percpu_user  cpu.cfs_init_buffer_us  docker
cpuacct.block_latency  cpuacct.stat                  cpuacct.usage_sys          cpu.cfs_period_us       notify_on_release
[root@iZbp1c0sait1zv807y3ok5Z ~]# 
</code></pre>
<p><strong>这里面有cfs_period 和 cfs_quota 这样的关键词。这两个参数需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</strong></p>
<p><strong>进入&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu这个目录，并再创建一个container目录，这个container目录就是一个“控制组”，目录下会自动生成该子系统对应的资源限制文件。</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z ~]# cd /sys/fs/cgroup/cpu
[root@iZbp1c0sait1zv807y3ok5Z cpu]# mkdir container
[root@iZbp1c0sait1zv807y3ok5Z cpu]# cd container/
[root@iZbp1c0sait1zv807y3ok5Z container]# ls
cgroup.clone_children        cpuacct.ioblock_latency       cpuacct.usage_all          cpuacct.usage_user      cpu.cfs_period_us  notify_on_release
cgroup.procs                 cpuacct.proc_stat             cpuacct.usage_percpu       cpuacct.wait_latency    cpu.cfs_quota_us   tasks
cpuacct.block_latency        cpuacct.sched_cfs_statistics  cpuacct.usage_percpu_sys   cpu.bvt_warp_ns         cpu.identity
cpuacct.cgroup_wait_latency  cpuacct.stat                  cpuacct.usage_percpu_user  cpu.cfs_burst_us        cpu.shares
cpuacct.enable_sli           cpuacct.usage                 cpuacct.usage_sys          cpu.cfs_init_buffer_us  cpu.stat
[root@iZbp1c0sait1zv807y3ok5Z container]# 
</code></pre>
<p><strong>尝试执行一条脚本</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z container]# while : ; do : ; done &amp;
[1] 273301
[root@iZbp1c0sait1zv807y3ok5Z container]# 
</code></pre>
<p><strong>273301 就是这个脚本的后台进程id，使用top观察cpu使用情况，此时这个进程使用了98.7的cpu资源</strong></p>
<pre><code class="shell">top - 15:02:17 up 168 days,  4:04,  1 user,  load average: 4.35, 1.93, 1.32
Tasks:  99 total,   2 running,  97 sleeping,   0 stopped,   0 zombie
%Cpu(s): 99.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.3 hi,  0.0 si,  0.0 st
MiB Mem :   1969.0 total,    440.2 free,    630.3 used,    898.6 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1193.1 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                           
 273301 root      20   0   20940   2688    640 R  98.7   0.1   0:47.92 bash   
</code></pre>
<p><strong>观察container目录下面的cpu.cfs_quota_us和cpu.cfs_period_us，发现cpu quota没有限制（-1），cpu period是默认的100ms（100000us）</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z container]# cat cpu.cfs_quota_us 
-1
[root@iZbp1c0sait1zv807y3ok5Z container]# cat cpu.cfs_period_us 
100000
[root@iZbp1c0sait1zv807y3ok5Z container]# 
</code></pre>
<p><strong>修改这两个文件内容来限制cpu资源的使用，比如将cpu quota时间设置为20ms，这样就意味着该进程在每个100ms期间只能使用cpu20ms，cpu占用将被控制在20%。</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z container]# echo 20000 &gt; cpu.cfs_quota_us 
</code></pre>
<p><strong>同时需要把限制进程的pid写入tasks文件</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z container]# echo 273301 &gt; tasks
</code></pre>
<pre><code class="shell">top - 15:23:29 up 168 days,  4:25,  1 user,  load average: 3.95, 5.14, 3.39
Tasks:  98 total,   2 running,  96 sleeping,   0 stopped,   0 zombie
%Cpu(s): 21.0 us,  0.3 sy,  0.0 ni, 77.7 id,  0.0 wa,  0.7 hi,  0.3 si,  0.0 st
MiB Mem :   1969.0 total,    439.6 free,    630.7 used,    898.7 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1192.6 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                           
 273301 root      20   0   20940   2704    640 R  20.3   0.1   7:18.07 bash   
</code></pre>
<p><strong>除 CPU 子系统外，Cgroups 的每一个子系统都有其独有的资源限制能力，比如：</strong></p>
<p><strong>blkio，为块设备设定I&#x2F;O 限制，一般用于磁盘等设备；</strong></p>
<p><strong>cpuset，为进程分配单独的 CPU 核和对应的内存节点；</strong></p>
<p><strong>memory，为进程设定内存使用的限制。</strong></p>
<p><strong>因此对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z docker]# docker run -d --cpu-period=100000 --cpu-quota=20000 myspringboot:v1
f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7
</code></pre>
<p><strong>容器id是 f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7</strong></p>
<p><strong>查看下docker目录，会生成一个f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7的目录，里面的cpu.cfs_quota_us被设置成了20000</strong></p>
<pre><code class="shell">[root@iZbp1c0sait1zv807y3ok5Z ~]# cd /sys/fs/cgroup/cpu/docker
[root@iZbp1c0sait1zv807y3ok5Z docker]# ls
cgroup.clone_children        cpuacct.sched_cfs_statistics  cpuacct.usage_sys       cpu.cfs_quota_us
cgroup.procs                 cpuacct.stat                  cpuacct.usage_user      cpu.identity
cpuacct.block_latency        cpuacct.usage                 cpuacct.wait_latency    cpu.shares
cpuacct.cgroup_wait_latency  cpuacct.usage_all             cpu.bvt_warp_ns         cpu.stat
cpuacct.enable_sli           cpuacct.usage_percpu          cpu.cfs_burst_us        f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7
cpuacct.ioblock_latency      cpuacct.usage_percpu_sys      cpu.cfs_init_buffer_us  notify_on_release
cpuacct.proc_stat            cpuacct.usage_percpu_user     cpu.cfs_period_us       tasks
[root@iZbp1c0sait1zv807y3ok5Z docker]# cd f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7/
[root@iZbp1c0sait1zv807y3ok5Z f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7]# ls
cgroup.clone_children        cpuacct.ioblock_latency       cpuacct.usage_all          cpuacct.usage_user      cpu.cfs_period_us  notify_on_release
cgroup.procs                 cpuacct.proc_stat             cpuacct.usage_percpu       cpuacct.wait_latency    cpu.cfs_quota_us   tasks
cpuacct.block_latency        cpuacct.sched_cfs_statistics  cpuacct.usage_percpu_sys   cpu.bvt_warp_ns         cpu.identity
cpuacct.cgroup_wait_latency  cpuacct.stat                  cpuacct.usage_percpu_user  cpu.cfs_burst_us        cpu.shares
cpuacct.enable_sli           cpuacct.usage                 cpuacct.usage_sys          cpu.cfs_init_buffer_us  cpu.stat
[root@iZbp1c0sait1zv807y3ok5Z f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7]# cat cpu.cfs_quota_us 
20000
[root@iZbp1c0sait1zv807y3ok5Z f74631b7712d0203dfe9f23d6b28d52beaf1ad53ccb40cc193cc927c03f27fe7]# 
</code></pre>

    </div>
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 NatureRan
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Nature
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
        <div>
            备案号：<a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">
                正在申请
            </a>
        </div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        
<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>
<script>
    var clientID = "240487ff75e73edeb415", clientSecret = "e4e29f4f7a4a8269fbd36fb31884017b1acda8cd";
    
    const gitalk = new Gitalk({
        clientID: clientID,
        clientSecret: clientSecret,
        repo: "natureran.github.io",
        owner: "NatureRan",
        admin: ["NatureRan"],
        language: "zh-CN",
        id: location.pathname,
        distractionFreeMode: false,
        
    })
    gitalk.render("gitalk-container")
</script>


    </body>

    <canvas
        id="fireworks"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:2147483647"
    ></canvas>
    <script type="text/javascript" src="/js/anime.js"></script>
    <script src="/js/fireworks.js"></script>

    <canvas
        id="background"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"
    ></canvas>
    <script src="/js/background.js"></script>

    <div id="cursor"></div>
    <script src="/css/cursor.css"></script>
    <script src="/js/cursor.js"></script>
</html>