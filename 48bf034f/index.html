
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Guava Caches文档 | NatureRan</title>
        <meta name="author" content="Nature">
        <meta name="description" content="">
        <meta name="keywords" content="java">
        <link rel="icon" href="https://raw.githubusercontent.com/NatureRan/Images/main/benghuai11-headImg.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">NatureRan</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NatureRan</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>Guava Caches文档 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
        
        <span class="category">
            <a href="/categories/文档/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                文档
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Java/" style="color: #00a596">
                    Java
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <div class="content-content">
            <h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumSize(1000)
       .expireAfterWrite(10, TimeUnit.MINUTES)
       .removalListener(MY_LISTENER)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             @Override
             public Graph load(Key key) throws AnyException &#123;
               return createExpensiveGraph(key);
             &#125;
           &#125;);
</code></pre>
<span id="more"></span>

<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><p><strong>缓存用非常广泛的使用场景，例如，当一个变量需要耗费巨大的资源来计算或检索得到并且你不止一次需要用到这个变量，你就需要考虑使用缓存。</strong></p>
<p><em><strong>Cache</strong></em> 类似于  <em><strong>ConcurrentMap</strong></em>，但也不完全相同，最根本的区别就是 <em><strong>ConcurrentMap</strong></em> 会保留所有被存储的元素直到它们被移除，相反 <em><strong>Cache</strong></em> 为了限制自身的内存占用，通常会按配置好的方式自动清除键值对。在某些场景下 <em><strong>LoadingCache</strong></em> 由于可以自动加载缓存，即使不使用自动清除键值对，它也非常好用。</p>
<p><strong>通常来说guava cache工具适用于以下一些场景：</strong></p>
<ul>
<li><strong>你想使用一些内存空间来改善程序运行速度</strong></li>
<li><strong>一些keys会被多次使用</strong></li>
<li><strong>你的缓存相对于机器内存来说占用量不是特别大（guava cache属于本地缓存，它是运行在单机应用上的，它不会把缓存存储到文件或其他服务器上面。如果这些不满足的需求，你需要考虑其他缓存工具比如</strong><a target="_blank" rel="noopener" href="http://memcached.org/"><em><strong>Memcached</strong></em></a>）</li>
</ul>
<p><strong>如果以上全部满足你的使用场景，那么guava cache工具将非常适合你！</strong></p>
<p>获得一个 <em><strong>Cache</strong></em> 对象只需要像示例中一样通过 <em><strong>CacheBuilder</strong></em> 的建造者模式创建，但是定制化你自己的 <em><strong>Cache</strong></em> 对象才是有意思的部分</p>
<p><strong>Note:如果你不需要使用 <em><strong>Cache</strong></em> 的特性，那么 <em><strong>ConcurrentHashMap</strong></em> 将更省内存，但是在任何老的 <em><strong>ConcurrentMap</strong></em> 上实现 <em><strong>Cache</strong></em> 的特性是非常困难甚至不可能的。</strong></p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p><strong>第一个关于缓存的问题便是，是否存在一个好用的默认方法来加载或计算一个key的值，如果有的话，你应该使用 <em><strong>CacheLoader</strong></em> 对象，如果没有或者说你需要重写这个默认方法，但是仍然想要一个满足”get-if-absent-compute”语法的原子操作，你应该在 <em><strong>get()</strong></em> 方法中传入一个 <em><strong>Callable</strong></em> 对象。使用 <em><strong>Cache.put</strong></em> 方法可以使元素立刻加入到缓存中去，但是自动化缓存加载更好是因为它更容易解决缓存内容一致性的问题。</strong></p>
<h2 id="使用CacheLoader"><a href="#使用CacheLoader" class="headerlink" title="使用CacheLoader"></a>使用CacheLoader</h2><p><em><strong>LoadingCache</strong></em> 是一个 <em><strong>Cache</strong></em> 在build中附带了一个<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html"><em><strong>CacheLoader</strong></em></a>。创建一个 <em><strong>CacheLoader</strong></em> 对象并实现 <em><strong>V load(K key) throws Exception</strong></em> 方法非常简单。因此，你可以用以下方式创建一个 <em><strong>LoadingCache</strong></em> 对象：</p>
<pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumSize(1000)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) throws AnyException &#123;
               return createExpensiveGraph(key);
             &#125;
           &#125;);
...
try &#123;
  return graphs.get(key);
&#125; catch (ExecutionException e) &#123;
  throw new OtherException(e.getCause());
&#125;
</code></pre>
<p><strong>典型的查询 <em><strong>LoadingCache</strong></em> 的方式是使用 <em><strong>get(k)</strong></em> 方法，这将会返回一个已经存在的缓存值，或者使用 <em><strong>CacheLoader</strong></em> 自动加载一个新的值到缓存中去。由于 <em><strong>CacheLoader</strong></em> 可能会抛出一个 <em><strong>Exception</strong></em> ，因此 <em><strong>LoadingCache.get(K)</strong></em> 会抛出  <em><strong>ExecutionException</strong></em></strong> （如果 <em><strong>CacheLoader</strong></em> 抛出的是非受检异常， <em><strong>get(k)</strong></em> 方法将会抛出 <em><strong>UncheckedExecutionException</strong></em> 来替换）。你也可以选择使用 <em><strong>getUnchecked(K)</strong></em> 方法，它会把所有异常都替换成 <em><strong>UncheckedExecutionException</strong></em> ，但是如果底层的 <em><strong>CacheLoader</strong></em> 抛出受检异常可能会导致一些意外的情况。</p>
<pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .expireAfterAccess(10, TimeUnit.MINUTES)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) &#123; // no checked exception
               return createExpensiveGraph(key);
             &#125;
           &#125;);
...
return graphs.getUnchecked(key);
</code></pre>
<p><strong>批量查找可以使用 <em><strong>getAll(Iterable&lt;? extends K&gt;)</strong></em> 方法。</strong> 在默认情况下， <em><strong>getAll</strong></em> 方法会对每个不存在于缓存中的key轮流调用 <em><strong>CacheLoader.load</strong></em> 方法。当批量检索比多个单次查询效率更高时，你可以重写 <em><strong>CacheLoader.loadAll</strong></em> 方法来开发这个功能， <em><strong>getAll(Iterable)</strong></em> 方法的性能将会有显著改善。 记住你可以重写 <em><strong>CacheLoader.loadAll</strong></em> 方法来批量加载缓存。例如：XXX</p>
<h2 id="关于Callable"><a href="#关于Callable" class="headerlink" title="关于Callable"></a>关于Callable</h2><p><strong>所有guava cache对象，不管用没有加载过数据，都支持 <em><strong>get(K, Callable)</strong></em> 方法，这个方法会返回缓存中已存在key值，若不存在，将会调用实现好的 <em><strong>Callable</strong></em> 方法来将值加载到缓存中。没有规定声明缓存在加载完成前不会被修改，这个方法提供了一个简单可替代的通俗模式“缓存存在即返回，不存在则创建”。</strong></p>
<pre><code class="java">Cache&lt;Key, Value&gt; cache = CacheBuilder.newBuilder()
    .maximumSize(1000)
    .build(); // look Ma, no CacheLoader
...
try &#123;
  // If the key wasn&#39;t in the &quot;easy to compute&quot; group, we need to
  // do things the hard way.
  cache.get(key, new Callable&lt;Value&gt;() &#123;
    @Override
    public Value call() throws AnyException &#123;
      return doThingsTheHardWay(key);
    &#125;
  &#125;);
&#125; catch (ExecutionException e) &#123;
  throw new OtherException(e.getCause());
&#125;
</code></pre>
<h2 id="直接插入缓存"><a href="#直接插入缓存" class="headerlink" title="直接插入缓存"></a>直接插入缓存</h2><p><strong>通过 <em><strong>cache.put(key, value)</strong></em> 方法可以直接将变量插入到缓存</strong>，这个操作会覆盖缓存中已存在key，变化后的值可以通过 <em><strong>Cache.asMap()</strong></em> 暴露出来的 <em><strong>ConcurrentMap</strong></em> 访问。需要注意的是 <em><strong>asMap</strong></em> 方法返回的对象不存在某个方法可以使数据自动加载到缓存。因此，在使用了 <em><strong>CacheLoader</strong></em> 或 <em><strong>Callable</strong></em> 实现的Cache中， <em><strong>Cache.get(K, Callable)</strong></em> 方法总是比 <em><strong>Cache.asMap().putIfAbsent</strong></em> 方法更好</p>
<h1 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h1><p><strong>然而冷酷无情的现实便是我们总是没有足够的内存去缓存所有的东西，你必须要考虑好，一个缓存的键值对何时不再需要。Guava提供了三种基本类型的缓存回收，基于空间回收，基于时间回收，基于引用回收。</strong></p>
<h2 id="基于空间回收"><a href="#基于空间回收" class="headerlink" title="基于空间回收"></a>基于空间回收</h2><p><strong>如果你的缓存不会超过一个具体的大小，使用</strong><a target="_blank" rel="noopener" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#maximumSize-long-"><em><strong>CacheBuilder.maximumSize(long)</strong></em></a> 来设置缓存最大存储空间，缓存将会自动尝试去回收一些不常用的键值对。警告：在最大缓存空间溢出之前，缓存就有可能会去回收键值对，尤其是快要溢出的时候。</p>
<p><strong>如果不同的缓存键值对有不同的“weights”，比如你的缓存键值对占用的内存空间截然不同——你可以具体实现一个</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weigher-com.google.common.cache.Weigher-"><em><strong>CacheBuilder.weigher(Weigher)</strong></em></a> 方法，并且设置 <em><strong>CacheBuilder.maximumWeight(long)</strong></em> 属性。除了 <em><strong>maximumSize</strong></em> 要求的警告事项之外，你需要注意weights是在键值对创建时就计算得出了，并且计算得出后不再变化。</p>
<pre><code class="java">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumWeight(100000)
       .weigher(new Weigher&lt;Key, Graph&gt;() &#123;
          public int weigh(Key k, Graph g) &#123;
            return g.vertices().size();
          &#125;
        &#125;)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) &#123; // no checked exception
               return createExpensiveGraph(key);
             &#125;
           &#125;);
</code></pre>
<h2 id="基于时间回收"><a href="#基于时间回收" class="headerlink" title="基于时间回收"></a>基于时间回收</h2><p><em><strong>CacheBuilder</strong></em> 提供了两种处理方式来实现时间回收：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#expireAfterAccess-long-java.util.concurrent.TimeUnit-"><em><strong>expireAfterAccess(long, TimeUnit)</strong></em></a> 一个键值对在最后一次读取后写入后经过指定的时间间隔就会被回收。需要注意的是键值对的回收顺序和基于空间回收的逻辑相似。</li>
<li><a target="_blank" rel="noopener" href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#expireAfterWrite-long-java.util.concurrent.TimeUnit-"><em><strong>expireAfterWrite(long, TimeUnit)</strong></em></a> 当一个键值对被创建或被重新写入的是开始计时，指定时间之后被回收。如果缓存数据每过一段时间就需要被淘汰的话就非常适合使用这种方式。</li>
</ul>
<h3 id="测试时间回收"><a href="#测试时间回收" class="headerlink" title="测试时间回收"></a>测试时间回收</h3><p><strong>测试时间回收并不是一件很痛苦的事情，因为你并不需要花费两秒钟的时间来等待一个设置了两秒过期的缓存。使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/base/Ticker.html"><em><strong>Ticker</strong></em></a>接口和<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#ticker-com.google.common.base.Ticker-"><em><strong>CacheBuilder.ticker(Ticker)</strong></em></a> 方法来指定一个时间源，而不是去等待系统时钟。</p>
<h2 id="基于引用回收"><a href="#基于引用回收" class="headerlink" title="基于引用回收"></a>基于引用回收</h2><p><strong>Guava允许你使用GC机制来回收缓存，对keys或values使用</strong><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html"><em><strong>weak references</strong></em></a>，对values使用<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html"><em><strong>soft references</strong></em></a>。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weakKeys--"><em><strong>CacheBuilder.weakKeys()</strong></em></a> 对keys使用弱引用，当没有其他对keys的强引用和软引用时，该键值对可以被GC。 符号来比较keys之间的相等，而不是 <em><strong>equals()</strong></em> 。</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weakValues--"><em><strong>CacheBuilder.weakValues()</strong></em></a> 对values使用弱引用，当没有其他对values的强引用和软引用时，该键值对可以被GC。</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#softValues--"><em><strong>CacheBuilder.softValues()</strong></em></a> 用软引用的方式覆盖values，按照内存要求，软引用对象在全局least-recently-used方式下可以被GC。因为使用软引用的性能暗示，我通常推荐使用可预测性更好的<a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/CachesExplained#Size-based-Eviction"><em><strong>maximum cache size</strong></em></a>，使用 <em><strong>softValues()</strong></em> 会导致values之间的比较会使用 <em><strong>(&#x3D;&#x3D;)</strong></em> 符号而不是 <em><strong>equals()</strong></em> 。</li>
</ul>
<h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p><strong>在任何时候，你可能明确知道要删除缓存而不是等待缓存被回收，以下可以实现：</strong></p>
<ul>
<li><strong>删除单个缓存，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#invalidate-java.lang.Object-"><em><strong>Cache.invalidate(key)</strong></em></a></li>
<li><strong>批量删除缓存，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#invalidateAll-java.lang.Iterable-"><em><strong>Cache.invalidateAll(keys)</strong></em></a></li>
<li><strong>删除全部缓存，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#invalidateAll--"><em><strong>Cache.invalidateAll()</strong></em></a></li>
</ul>
<h2 id="缓存删除监听器"><a href="#缓存删除监听器" class="headerlink" title="缓存删除监听器"></a>缓存删除监听器</h2><p><strong>你可以实现一个缓存删除监听器在缓存被删除的时候完成一些操作，通过</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#removalListener-com.google.common.cache.RemovalListener-"><em><strong>CacheBuilder.removalListener(RemovalListener)</strong></em></a> 注册监听器。<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalListener.html"><em><strong>RemovalListener</strong></em></a>传入一个<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalNotification.html"><em><strong>RemovalNotification</strong></em></a>参数，它详细指定了<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalCause.html">RemovalCause</a>，key和value。 需要注意的是 <em><strong>RemovalListener</strong></em> 抛出的所有异常都会被吞掉并用Logger打印。</p>
<pre><code class="java">CacheLoader&lt;Key, DatabaseConnection&gt; loader = new CacheLoader&lt;Key, DatabaseConnection&gt; () &#123;
  public DatabaseConnection load(Key key) throws Exception &#123;
    return openConnection(key);
  &#125;
&#125;;
RemovalListener&lt;Key, DatabaseConnection&gt; removalListener = new RemovalListener&lt;Key, DatabaseConnection&gt;() &#123;
  public void onRemoval(RemovalNotification&lt;Key, DatabaseConnection&gt; removal) &#123;
    DatabaseConnection conn = removal.getValue();
    conn.close(); // tear down properly
  &#125;
&#125;;
return CacheBuilder.newBuilder()
  .expireAfterWrite(2, TimeUnit.MINUTES)
  .removalListener(removalListener)
  .build(loader);
</code></pre>
<p> <strong>警告</strong> <strong>：缓存删除监听器默认情况下是同步执行的，当缓存维护器在正常执行时，缓存删除监听器的可能会拖慢你的缓存使用！如果你的缓存删除监听器效率不是很高，使用</strong><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalListeners.html#asynchronous-com.google.common.cache.RemovalListener-java.util.concurrent.Executor-"><em><strong>RemovalListeners.asynchronous(RemovalListener, Executor)</strong></em></a> 来装饰 <em><strong>RemovalListener</strong></em> 实现异步操作。</p>
<h2 id="缓存是何时清除的"><a href="#缓存是何时清除的" class="headerlink" title="缓存是何时清除的"></a>缓存是何时清除的</h2><p><em><strong>CacheBuilder</strong></em> 创建的 <em><strong>Caches</strong></em> 对象不会“自动”清除缓存中的值。只有在写入操作时才会有少数维护操作，当写入操作较少时，会在偶然的读取操作时触发。 原因如下：如果我们想让 <em><strong>Caches</strong></em> 连续不断地去维护，我们需要创建一个线程，并且它的操作可能会和用户的操作去竞争锁。此外，一些环境会限制线程的创建，这会使得 <em><strong>CacheBuilder</strong></em> 在这些环境下不可用。 我们把选择权交给了你，如果你的缓存吞吐量很高，那你不需要担心缓存维护去执行对过期键值对的清除。如果你的缓存很少有写入操作，并且不希望缓存清除导致读取阻塞，你可以去创建你自己的维护线程定时调用 <a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/11.0.1/api/docs/com/google/common/cache/Cache.html#cleanUp--"><em><strong>Cache.cleanUp()</strong></em></a> 方法。 如果你想对一个写入频率较少的缓存定时使用缓存维护，可以使用 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html"><em><strong>ScheduledExecutorService</strong></em></a></p>
<h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p><strong>缓存刷新和缓存回收不太一样</strong>，在<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/LoadingCache.html#refresh-K-"><em><strong>LoadingCache.refresh(K)</strong></em></a> 这个方法的文档中，刷新一个key的值会往缓存中加载一个新的value，这个操作是可以异步的。缓存刷新的同时，老的value会被该方法返回。 如果刷新缓存的过程中抛出异常，那么老的value将被保留，同时该异常会被吞掉并通过logger打印出来。 重写 <em><strong>CacheLoader</strong></em> 的 <a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheLoader.html#reload-K-V-"><em><strong>CacheLoader.reload(K, V)</strong></em></a> 方法可以实现缓存刷新操作，这个方法允许你使用老value来计算出新的value。</p>
<pre><code class="java">// Some keys don&#39;t need refreshing, and we want refreshes to be done asynchronously.
LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()
       .maximumSize(1000)
       .refreshAfterWrite(1, TimeUnit.MINUTES)
       .build(
           new CacheLoader&lt;Key, Graph&gt;() &#123;
             public Graph load(Key key) &#123; // no checked exception
               return getGraphFromDatabase(key);
             &#125;
             public ListenableFuture&lt;Graph&gt; reload(final Key key, Graph prevGraph) &#123;
               if (neverNeedsRefresh(key)) &#123;
                 return Futures.immediateFuture(prevGraph);
               &#125; else &#123;
                 // asynchronous!
                 ListenableFutureTask&lt;Graph&gt; task = ListenableFutureTask.create(new Callable&lt;Graph&gt;() &#123;
                   public Graph call() &#123;
                     return getGraphFromDatabase(key);
                   &#125;
                 &#125;);
                 executor.execute(task);
                 return task;
               &#125;
             &#125;
           &#125;);
</code></pre>
<p><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#refreshAfterWrite-long-java.util.concurrent.TimeUnit-"><em><strong>CacheBuilder.refreshAfterWrite(long, TimeUnit)</strong></em></a> 方法可以实现缓存自动定时刷新。和 <em><strong>expireAfterWrite</strong></em> 方法不同的是，<em><strong>refreshAfterWrite</strong></em> 会使得key在指定时间后进行刷新，但实际上缓存刷新只会在键值对被查询时被触发（如果 <em><strong>CacheLoader.reload</strong></em> 方法时异步实现的，那查询不会因为刷新变得更慢）。例如，你同时设置了 <em><strong>refreshAfterWrite</strong></em> 和 <em><strong>expireAfterWrite</strong></em> ，那么这种情况下，就算这个键值对满足刷新条件，它的过期时间也不会被重置，因此当一个键值对满足刷新条件但没有被查询的话，它依然允许被回收。</p>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/12.0/api/docs/com/google/common/cache/CacheBuilder.html#recordStats--"><em><strong>CacheBuilder.recordStats()</strong></em></a> 可以打开guava cache的数据收集功能， <a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/Cache.html#stats--"><em><strong>Cache.stats()</strong></em></a> 返回一个<a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html"><em><strong>CacheStats</strong></em></a> 对象，它能提供以下数据统计：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html#hitRate--"><em><strong>hitRate()</strong></em></a> 返回查询请求的命中率</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html#averageLoadPenalty--"><em><strong>averageLoadPenalty()</strong></em></a> 加载新value的平均时间，单位：纳秒</li>
<li><a target="_blank" rel="noopener" href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheStats.html#evictionCount--"><em><strong>evictionCount()</strong></em></a> 缓存回收的次数 除此之外还有许多其他的数据统计项，这些统计信息对于缓存调整至关重要，我们建议在性能要求较高的应用中多多注意这些数据指标。</li>
</ul>
<h2 id="asMap"><a href="#asMap" class="headerlink" title="asMap"></a>asMap</h2><p><strong>你可以使用 <em><strong>asMap</strong></em> 将任何一个 <em><strong>Cache</strong></em> 对象视为 <em><strong>ConcurrentMap</strong></em> ，但是 <em><strong>asMap</strong></em> 如何影响 <em><strong>Cache</strong></em> 这里需要解释：</strong></p>
<ul>
<li><em><strong>cache.asMap()</strong></em> 包含缓存中目前存储的所有键值对，因此例如：<em><strong>cache.asMap().keySet()</strong></em> 包含缓存中所有的keys</li>
<li><em><strong>asMap().get(key)</strong></em> 本质上等同于 <em><strong>cache.getIfPresent(key)</strong></em> ，不会使得value被加载到缓存。这和 <em><strong>Map</strong></em> 的协议一致</li>
<li><strong>缓存的访问时间会被任何读取和写入操作重置</strong>（包括 <em><strong>Cache.asMap().get(Object)</strong></em> 和 <em><strong>Cache.asMap().put(K, V)</strong></em> ），但是不包括 <em><strong>containsKey(Object)</strong></em> ，也不包括 <em><strong>Cache.asMap()</strong></em> 。因此比如：通过 <em><strong>cache.asMap().entrySet()</strong></em> 迭代键值对不会重置缓存的访问时间</li>
</ul>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p><strong>参考：</strong><a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/CachesExplained"><em><strong>https://github.com/google/guava/wiki/CachesExplained</strong></em></a></p>

        </div>
        <div class="content-toc">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%80%A7"><span class="toc-text">适用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%BC%E8%BF%B0"><span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CacheLoader"><span class="toc-text">使用CacheLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECallable"><span class="toc-text">关于Callable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E7%BC%93%E5%AD%98"><span class="toc-text">直接插入缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6"><span class="toc-text">回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6"><span class="toc-text">基于空间回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%9B%9E%E6%94%B6"><span class="toc-text">基于时间回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%97%B6%E9%97%B4%E5%9B%9E%E6%94%B6"><span class="toc-text">测试时间回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E5%9B%9E%E6%94%B6"><span class="toc-text">基于引用回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-text">删除缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%88%A0%E9%99%A4%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">缓存删除监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%98%AF%E4%BD%95%E6%97%B6%E6%B8%85%E9%99%A4%E7%9A%84"><span class="toc-text">缓存是何时清除的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B7%E6%96%B0"><span class="toc-text">刷新</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1"><span class="toc-text">统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asMap"><span class="toc-text">asMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a></li></ol>
        </div>
    </div>
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 NatureRan
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Nature
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
        <div>
            备案号：<a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">
                浙ICP备2022026588号-1
            </a>
        </div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        
<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>
<script>
    var clientID = "240487ff75e73edeb415", clientSecret = "e4e29f4f7a4a8269fbd36fb31884017b1acda8cd";
    
    const gitalk = new Gitalk({
        clientID: clientID,
        clientSecret: clientSecret,
        repo: "natureran.github.io",
        owner: "NatureRan",
        admin: ["NatureRan"],
        language: "zh-CN",
        id: location.pathname,
        distractionFreeMode: false,
        
    })
    gitalk.render("gitalk-container")
</script>


    </body>

    <canvas
        id="fireworks"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:2147483647"
    ></canvas>
    <script type="text/javascript" src="/js/anime.js"></script>
    <script src="/js/fireworks.js"></script>

    <canvas
        id="background"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"
    ></canvas>
    <script src="/js/background.js"></script>

    <div id="cursor"></div>
    <script src="/css/cursor.css"></script>
    <script src="/js/cursor.js"></script>
</html>